/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package it.unipd.threewaymilkshake.portacs.server;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TimerTask;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ServerCentrale {

    LinkedList<Muletto> currentMulettos = new LinkedList<Muletto>();

    
    public ServerCentrale(LinkedList<Muletto> currentMulettos) {
        this.currentMulettos = currentMulettos;
    }

    /*public void startServer() {

        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        executor.scheduleAtFixedRate(() -> organizer(), 250L, 500L, TimeUnit.MILLISECONDS);

    }*/

    public void organizer() {
        // System.out.println("***");
    
        //check if empty
        
        generateMatrix(currentMulettos);
        //currentMulettos.getFirst().out.print("STOP,1");

        for(Muletto mul : currentMulettos) {
            for(Character move : mul.pathToNextTask) {
                System.out.print(move);
            }
            System.out.print("\n");
        }
        

        HashMap<Point, LinkedList<Muletto>> collisionDetected = Collision.CollisionDetector(new HashSet<Muletto>(currentMulettos));
       
        Collision.printCollisionDetected(collisionDetected);
        
        Solver solver = new Solver(collisionDetected);

        HashMap<Muletto,Action> responses = solver.collisionSolver();
        responses.forEach((k, v)->{
            if(!v.actions.isEmpty()){
                k.out.print("STOP,1");
                k.pathToNextTask.addFirst(moveToCharacter(k.nextMoves.getFirst()));
            }
        });
        
        solver.printResponse();

        
        
        // System.out.println("***");
        currentMulettos.clear();
    }

    public Character moveToCharacter(Move m) {
        if(m == Move.TURNRIGHT)
            return 'R';
        else if(m == Move.TURNLEFT)
            return 'L';
        else if(m == Move.TURNBACK)
            return 'T';
        else if(m == Move.STOP)
            return 'S';
        else
            return 'M';
    }

    public void generateMatrix(LinkedList<Muletto> currentMulettos) {
        
        for(Muletto con : currentMulettos)
        {
            System.out.println("Ricevuto muletto " + con.id + con.position.printPosition() + " nextTwoMoves: ");
            con.printNextMoves();
        }
        

        /*
        int[][] map = {
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 },
            { 0,0,0,0,0,0,0,0,0,0 }
        };

        for(Muletto con : currentMulettos)
        {
            map[con.position.getX()][con.position.getY()] = 1;
        }

        for(int i = 0; i < 10; i++) 
        {
            for(int j = 0; j < 10; j++)
            {
                System.out.printf(map[i][j] + " ");
            }
            System.out.printf("\n");
        }
        */

    }


    

}
